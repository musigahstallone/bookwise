
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A book recommendation AI agent.
 *
 * - getBookRecommendation - A function that handles the book recommendation process.
 * - BookRecommendationInput - The input type for the getBookRecommendation function.
 * - BookRecommendationOutput - The return type for the getBookRecommendation function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const BookRecommendationInputSchema = z.object({
  userInput: z
    .string()
    .describe(
      'The description of the desired book or current mood of the user.'
    ),
  bookDescriptions: z.array(
    z.object({
      title: z.string(),
      description: z.string(),
    })
  ).describe('An array of book descriptions to use for recommendations.'),
});
export type BookRecommendationInput = z.infer<typeof BookRecommendationInputSchema>;

const BookRecommendationOutputSchema = z.object({
  recommendedBooks: z.array(
    z.object({
      title: z.string().describe('The title of the recommended book.'),
      reason: z.string().describe('The reason why this book is recommended.'),
    })
  ).describe('The recommended books based on the user input.'),
});
export type BookRecommendationOutput = z.infer<typeof BookRecommendationOutputSchema>;

export async function getBookRecommendation(input: BookRecommendationInput): Promise<BookRecommendationOutput> {
  const genkitKeyIsSet = !!process.env.GOOGLE_API_KEY;
  if (!genkitKeyIsSet) {
    console.warn("AI Recommender (Genkit/Google AI) is not configured due to missing API key. Returning empty recommendations.");
    // Optionally, you could throw an error that the client can catch and display.
    // throw new Error("AI Recommender is not configured. Please contact support.");
    return { recommendedBooks: [] };
  }
  return bookRecommendationFlow(input);
}

const prompt = ai.definePrompt({
  name: 'bookRecommendationPrompt',
  input: {schema: BookRecommendationInputSchema},
  output: {schema: BookRecommendationOutputSchema},
  model: 'googleai/gemini-2.0-flash', // Specify the model here
  prompt: `You are a book recommendation expert. A user will describe their current mood, or the type of book they are looking for. You will suggest books from the available catalog that best fit their needs.

User Input: {{{userInput}}}

Available Books:
{{#each bookDescriptions}}
Title: {{this.title}}
Description: {{this.description}}
{{/each}}

Based on the user input, recommend books from the available catalog and explain why each book is recommended.`,  
});

const bookRecommendationFlow = ai.defineFlow(
  {
    name: 'bookRecommendationFlow',
    inputSchema: BookRecommendationInputSchema,
    outputSchema: BookRecommendationOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
//explain whats going on here
// This code defines a book recommendation AI agent using Genkit and Google AI.
// It includes a function to get book recommendations based on user input and a predefined set of book descriptions.
// The input and output schemas are defined using Zod for type safety.
// The AI agent uses a prompt that instructs it to recommend books based on the user's mood or preferences.
// The flow is defined to process the input and return the recommended books along with reasons for the recommendations.
// The AI agent is configured to use the Google AI model "gemini-2.0-flash" for generating recommendations.
// If the Genkit configuration is not set up (e.g., missing API key), it logs a warning and returns an empty recommendation list.
// The code is structured to be used in a server-side environment, as indicated by the 'use server' directive at the top.
// The `isGenkitConfigured` flag is used to check if the Genkit AI is properly configured before making any AI calls, 
// ensuring that the application can handle cases where the AI features are not available.
// This setup allows for a flexible and type-safe way to integrate AI-driven book recommendations into the application.
// The use of Zod schemas ensures that the input and output data structures are validated, providing type safety and reducing runtime errors.





