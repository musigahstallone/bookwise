
'use server';

import { revalidatePath } from 'next/cache';
import { db } from '@/lib/firebase';
import {
  collection,
  addDoc,
  serverTimestamp,
  Timestamp,
  doc,
  updateDoc,
  getDocs, // Added for download limit check
  query, // Added for download limit check
  where, // Added for download limit check
} from 'firebase/firestore';
import type { PaymentMethod } from '@/lib/payment-service';

export interface OrderItemInput {
  bookId: string;
  title: string;
  price: number; // This is the USD price from the book catalog for consistency in item data
  coverImageUrl: string;
  pdfUrl: string;
  dataAiHint?: string;
}

export type OrderStatus = "pending" | "completed" | "failed" | "cancelled";

// This interface defines the data expected when creating an order.
export interface CreateOrderData {
    userId: string;
    userEmail?: string | null;
    items: OrderItemInput[];
    totalAmountUSD: number; // Base USD total for the order
    regionCode: string;
    currencyCode: string; // Currency code of the selected region for display/payment
    actualAmountPaid: number; // The amount the user actually pays in their selected currency
    itemCount: number;
    status: OrderStatus;
    paymentGatewayId?: string | null; // ID from payment provider (e.g., Stripe PaymentIntent ID, M-Pesa CheckoutRequestID)
    paymentMethod?: PaymentMethod | null;
    // Note: orderId is generated by Firestore, not passed in here.
}


// Server Action to create an order
export async function handleCreateOrder(
  orderData: CreateOrderData
): Promise<{ success: boolean; message?: string; orderId?: string }> {
  if (!orderData.userId) {
    return { success: false, message: 'User ID missing for order creation.' };
  }
   if (!process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID) {
    return { success: false, message: "Firebase Project ID not configured." };
  }

  try {
    // Sanitize items to ensure no undefined fields are passed to Firestore
    const cleanItems = orderData.items.map(item => ({
      bookId: item.bookId || 'unknown_book_id',
      title: item.title || 'Unknown Title',
      price: typeof item.price === 'number' ? item.price : 0,
      coverImageUrl: item.coverImageUrl || 'https://placehold.co/100x100.png?text=No+Cover',
      pdfUrl: item.pdfUrl || '/pdfs/placeholder-book.pdf',
      dataAiHint: item.dataAiHint || 'book',
    }));

    const orderDocData = {
      userId: orderData.userId,
      userEmail: orderData.userEmail || null,
      items: cleanItems,
      totalAmountUSD: typeof orderData.totalAmountUSD === 'number' ? orderData.totalAmountUSD : 0,
      actualAmountPaid: typeof orderData.actualAmountPaid === 'number' ? orderData.actualAmountPaid : 0,
      orderDate: serverTimestamp(),
      regionCode: orderData.regionCode || 'N/A',
      currencyCode: orderData.currencyCode || 'N/A',
      itemCount: typeof orderData.itemCount === 'number' ? orderData.itemCount : 0,
      status: orderData.status || 'failed',
      paymentGatewayId: orderData.paymentGatewayId || null,
      paymentMethod: orderData.paymentMethod || null,
      lastUpdatedAt: serverTimestamp(),
    };
    
    const orderRef = await addDoc(collection(db, 'orders'), orderDocData);
    
    console.log(`Order ${orderRef.id} created with status: ${orderData.status}`);
    
    revalidatePath('/admin/orders');
    revalidatePath(`/my-orders`);
    revalidatePath(`/orders/${orderRef.id}`);
    if (orderData.status === "completed") {
        revalidatePath('/admin'); // For dashboard stats
    }

    return { success: true, message: 'Order created successfully.', orderId: orderRef.id };
  } catch (error) {
    console.error('Error creating order:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return { success: false, message: `Failed to create order: ${errorMessage}` };
  }
}

// Server action to update an order's status and related payment details
export async function updateOrderStatus( // Renamed from handleUpdateOrderStatus for clarity
  orderId: string,
  status: OrderStatus,
  paymentDetails?: { paymentGatewayId?: string; paymentMethod?: PaymentMethod; actualAmountPaid?: number; currencyCode?: string; }
): Promise<{ success: boolean; message?: string }> {
  if (!process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID) {
    return { success: false, message: "Firebase Project ID not configured." };
  }
  if (!orderId) {
    return { success: false, message: "Order ID is required to update status." };
  }

  try {
    const orderDocRef = doc(db, 'orders', orderId);
    const updateData: any = { 
      status, 
      lastUpdatedAt: serverTimestamp() 
    };

    if (paymentDetails) {
      if (paymentDetails.paymentGatewayId) {
        updateData.paymentGatewayId = paymentDetails.paymentGatewayId;
      }
      if (paymentDetails.paymentMethod) {
        updateData.paymentMethod = paymentDetails.paymentMethod;
      }
      if (typeof paymentDetails.actualAmountPaid === 'number') {
        updateData.actualAmountPaid = paymentDetails.actualAmountPaid;
      }
       if (paymentDetails.currencyCode) {
        updateData.currencyCode = paymentDetails.currencyCode;
      }
    }
    
    await updateDoc(orderDocRef, updateData);

    revalidatePath('/admin/orders');
    revalidatePath(`/my-orders`);
    revalidatePath(`/orders/${orderId}`);
    if (status === "completed") {
      revalidatePath('/admin'); // For dashboard stats
    }
    console.log(`Order ${orderId} status updated to ${status}.`);
    return { success: true, message: `Order ${orderId} status updated to ${status}.` };
  } catch (error) {
    console.error(`Error updating order ${orderId} status:`, error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return { success: false, message: `Failed to update order status: ${errorMessage}` };
  }
}


const BOOK_DOWNLOADS_COLLECTION = 'bookDownloads';
const MAX_DOWNLOADS_PER_DAY = 5; // Example limit

export async function handleRecordDownload(
  bookId: string,
  userId: string
): Promise<{ success: boolean; message?: string }> {
  if (!process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID) {
    return { success: false, message: "Firebase Project ID not configured." };
  }
  if (!bookId || !userId) {
    return { success: false, message: "Book ID or User ID missing for download record." };
  }

  try {
    const today = new Date();
    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    // const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1); // Not strictly needed with serverTimestamp filtering

    const downloadsQuery = query(
      collection(db, BOOK_DOWNLOADS_COLLECTION),
      where('userId', '==', userId),
      where('downloadedAt', '>=', Timestamp.fromDate(startOfDay))
      // where('downloadedAt', '<', Timestamp.fromDate(endOfDay)) // Querying up to end of day
    );
    
    const downloadsSnapshot = await getDocs(downloadsQuery);
    
    let todayDownloads = 0;
    downloadsSnapshot.forEach(docSnap => {
        const downloadTimestamp = docSnap.data().downloadedAt as Timestamp;
        // Ensure downloadedAt exists and is a Firestore Timestamp before converting
        if (downloadTimestamp && typeof downloadTimestamp.toDate === 'function') {
            const downloadedAtDate = downloadTimestamp.toDate();
            if (downloadedAtDate >= startOfDay) {
                todayDownloads++;
            }
        }
    });

    if (todayDownloads >= MAX_DOWNLOADS_PER_DAY) {
      return { success: false, message: `You have reached your daily download limit of ${MAX_DOWNLOADS_PER_DAY} books.` };
    }

    await addDoc(collection(db, BOOK_DOWNLOADS_COLLECTION), {
      bookId,
      userId,
      downloadedAt: serverTimestamp(),
    });

    revalidatePath('/admin/downloads'); // For admin view
    revalidatePath('/admin'); // For dashboard stats if downloads are counted

    return { success: true, message: "Download recorded." };
  } catch (error) {
    console.error('Error recording download:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred while recording download.';
    return { success: false, message: errorMessage };
  }
}
